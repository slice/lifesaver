{ lifesaver,

# The Python interpreter must be configured with packages (incl. Lifesaver) by
# the caller. This file does not call `withPackages` because it doesn't stack,
# so if we did it here, it would just override all of the dependencies the
# caller wants.
python, }:

{ name, src, description ? "Lifesaver bot ${name}", hardConfig ? { },

# Whether to change the working directory to the source path before running the
# bot.
#
# There are two main ways to deploy Lifesaver bots:
#
#   1) Ad-hoc: You don't make a real Python package out of your bot. When
#   booting the bot, the NixOS module generated by this file `cd`s into the
#   directory that contains the bot's source code. Lifesaver is already
#   installed in the Python environment, and can find your bot's code because
#   `.` is in `PYTHONPATH`. This is exactly how Lifesaver bots were typically
#   deployed pre-Nix.
#
#   2) Packaged: A Python package is made from your bot (using setuptools,
#   etc.) `hardConfig` is used to override any Lifesaver bot configuration
#   options that are tweakable from the exported NixOS module - specifically,
#   the bot class and other runtime classes are hardcoded to refer to the
#   Python package, so that any consumers of the bot can never modify these
#   values (which is what you want), and everything points to the right place
#   no matter what the current working directory is.
#
# Notably, bots that use the ad-hoc method _cannot use `Storage` with files
# that live the current working directory_, because the working directory is
# read-only under Nix. If the following value is set to `false`, then we `cd`
# to the data directory instead, which is where the cog-specific configurations
# are linked. This location _is_ writable, but it means that you are forced to
# make a real Python package out of your bot, since we can no longer assume the
# bot's code is in `.` anymore, and it doesn't seem particularly hygienic to
# link or copy all of the bot's code into the data directory.
adhoc ? true,

# The list of extensions to load when starting up. This needs to be set if
# `adhoc` is `false`, because the bot can't infer the list of extensions needed
# from a Python package. This might be better off as Python package metadata
# instead, but that's a TODO.
loadList ? [ ],

... }:

assert !adhoc -> (loadList != [ ]);

{ config, lib, pkgs, ... }:

let
  cfg = config.lifesaver.${name};
  yaml = pkgs.formats.yaml { };
  defaultCogConfigPath = "${cfg.dataDir}/config";
  effectiveHardConfig = hardConfig // { load_list = loadList; };
in {
  options.lifesaver.${name} = with lib; {
    enable = mkEnableOption ''Enables Lifesaver-powered Discord bot "${name}"'';

    token = mkOption {
      type = types.str;
      description = "The token of the bot. Used to authenticate with Discord.";
    };

    python = mkOption {
      type = types.package;
      default = python;
      description = "The Python package to use for the bot.";
    };

    dataDir = mkOption {
      type = types.path;
      default = "/var/lib/lifesaver-${name}";
      description = "The data directory that the bot runs in.";
    };

    loadDefaultCogs = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to pass `--no-default-cogs` to the Lifesaver CLI.";
    };

    user = mkOption {
      type = types.str;
      default = "lifesaver";
      description = "The user account to run the bot under.";
    };

    group = mkOption {
      type = types.str;
      default = "lifesaver";
      description = "The group to run the bot under.";
    };

    settings = mkOption {
      type = types.submodule {
        freeformType = yaml.type;

        options = let opt = type: default: mkOption { inherit type default; };
        in {
          # Troubling: if we want to specify the types of these settings, we
          # also have to give a default value which _will_ be used unless
          # overridden. These have to ~match the defaults in Lifesaver.

          bot_class = opt (types.nullOr types.str) null;
          config_class = opt (types.nullOr types.str) null;
          extensions_path = opt types.str "./exts";
          cog_config_path = opt types.str defaultCogConfigPath;
          load_list = opt (types.listOf types.str) null;
          ignore_bots = opt types.bool true;
          command_prefix =
            opt (types.either (types.listOf types.str) types.str) "!";
          intents =
            opt (types.either (types.listOf types.str) types.str) "default";
          description = opt types.str description;
          dm_help = opt (types.nullOr types.bool) null;
          command_prefix_include_mentions = opt (types.nullOr types.bool) true;
          hot_reload = opt types.bool false;
          emojis = opt (types.attrsOf types.anything) { };
          postgres = opt (types.nullOr (types.attrsOf types.anything)) null;
        };
      };

      description =
        "Extra configuration options to be serialized into the YAML file.";
      default = { };
      example = literalExpression ''{ command_prefix = ["?"]; }'';
    };

    cogConfig = mkOption {
      type = types.attrsOf yaml.type;
      description =
        "Configuration options for cogs that use `@lifesaver.Cog.with_config`.";
      default = { };
    };
  };

  config = lib.mkIf cfg.enable {
    users.users = lib.mkIf (cfg.user == "lifesaver") {
      lifesaver = {
        group = cfg.group;
        isSystemUser = true;
      };
    };
    users.groups = lib.mkIf (cfg.group == "lifesaver") { lifesaver = { }; };

    systemd.tmpfiles.rules =
      [ "d ${cfg.dataDir} 0750 ${cfg.user} ${cfg.group} -" ];

    systemd.services."lifesaver-${name}" = let
      python = cfg.python;

      botYamlConfig = yaml.generate "lifesaver-${name}-config.yml" ({
        token = cfg.token;
        logging.file = "${cfg.dataDir}/bot.log";
      } // cfg.settings // effectiveHardConfig);

      cogConfigs = lib.mapAttrs (cogName: config:
        yaml.generate "lifesaver-${name}-cog-${cogName}-config.yml" config)
        cfg.cogConfig;

      usingNonstandardCogConfigPath = cfg.settings.cog_config_path
        != defaultCogConfigPath;
      linkCogConfigsPreamble = ''
        echo "Linking in cog configurations"
        cd ${cfg.dataDir}
        mkdir -p config
      '';
      # Don't bother linking cog configurations into the data directory if
      # the user has specified them to be located elsewhere.
      linkCogConfigsShell = if usingNonstandardCogConfigPath then
        ''
          echo "Not linking in cog configurations; using nonstandard cog config path"''
      else
        linkCogConfigsPreamble + (builtins.concatStringsSep "\n"
          (lib.mapAttrsToList
            (cogName: file: "ln -sf ${file} config/${cogName}.yml")
            cogConfigs));

      cdShell = if adhoc then ''
        echo "Starting Lifesaver Discord bot (ad-hoc) with source code at: ${src}"
        cd ${src}
      '' else ''
        echo "Starting Lifesaver Discord bot (not ad-hoc, using Python package)"
      '';
    in {
      wantedBy = [ "multi-user.target" ];
      script = ''
        ${linkCogConfigsShell}
        ${cdShell}
        echo "Current working directory: $(pwd)"
        ${python}/bin/python -mlifesaver.cli --config=${botYamlConfig}
      '';
      environment = {
        NIX = "1";

        # When running, $TEMP, $TEMPDIR, and $TMP will be empty. Manually set
        # it to somewhere writable for the bot, because
        # `lifesaver.bot.Storage` needs to atomically write JSON files.
        TEMP = cfg.dataDir;

        DATA_DIRECTORY = cfg.dataDir;
      };
      inherit description;
      serviceConfig = {
        Type = "simple";
        Restart = "on-failure";
        User = cfg.user;
        Group = cfg.group;
        WorkingDirectory = cfg.dataDir;
      };
    };
  };
}
